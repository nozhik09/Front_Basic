// * Методы массивов

// мы уже знаем методы добавления / удаления элементов:

// *pop(), мутирующий, удаляет с конца, возвращает удаленный элемент
// *push(), мутирующий, добавляет к концу, возвращает длину нового массива
// *shift(), мутирующий, удаляет из начала, возвращает удаленный элемент
// *unshift(), мутирующий, добавляет в начало, возвращает длину нового массива

// * forEach(), мутирующий, производит заданные операции с каждым элементом массива, возвращает undefined
// * map(), не мутирующий, возвращает новый массив с элементами, итерируется по старому массиву с доступом к его элементам
// * filter(), не мутирующий, возвращает новый массив с элементами, которые удовлетворяют условию фильтрации
// * find(), не мутирующий, возвращает первый элемент, который удовлетворяет условию
// если не найдет элемент вернет undefined

// * reduce(), не мутирующий, возвращает новый массив с элементами =>
// => принимает два аргумента: стрелочную функция с двумя параметрами (аккумулятор, промежуточное значение)
// => начальное значение
// * reverse(), не мутирующий, возвращает новый массив с элементами в обратном порядке
// * join(), не мутирующий, возвращает строку объединенную соединителем строкой
// * splice(), мутирующий, принимает два параметра =>
// индекс начала ==>
// кол-во элементов (не обязательный)
// возвращает удаленные элементы
// * sort()
// мутирующий, сортирует исходный массив, возвращает также отсортированный массив (2 в 1)
// по умолчанию числа сортирует как строки, работает в алфавитном порядке
// при сортировке строк: приведите в единый регистр
// при сортировки чисел: передайте функцию сортировки: arr.sort((a, b) => a - b)
// ? методы строк и массивов
// * slice(), возвращает новый массив / строку, возвращает новый массив / строку, принимает два параметра =>
// => индекс начального элемента включительно ==>
// => индекс до которого не включительно (не обязательный параметр)
// ? методы строк
// * split(), принимает разделитель строку, возвращает массив строк по разделителю
// * toUpperCase()
// * toLowerCase()
// * charAt()
// * concat()
// метод не мутирующий
// возвращает объединенный массив
// вы можете передавать несколько массивов, в качестве аргументов для объединения
// * 2 includes()
// принимает значение, и ищет его соответствие в массиве
// через оператор && можно передавать несколько значения для поиска
// возвращает булевое значение
// * 3 findIndex()
// не мутирующий
// принимает стрелочную функцию
// возвращает индекс первого элемента, который удовлетворяет условию
// ! если не один из элементов не удовлетворяет условию - вернет -1
// *replace()
// метод только для строк
// заменяет подстроку в строке
// принимает что будет изменять первым аргументом, и на что поменяет вторым аргументом
// вернет массив неизменным, если не получится найти подстроку

// имеем большую строку







const brothers = [
    { name: 'Legolas', height: 190, race: 'elf', age: 500, hasMagic: true },
    { name: 'Aragorn', height: 180, race: 'human', age: 50, hasMagic: false },
    { name: 'Gimli', height: 50, race: 'dwarf', age: 200, hasMagic: false },
    { name: 'Gendalf', height: 200, race: 'mayar', age: 2000, hasMagic: true },
    { name: 'Frodo', height: 60, race: 'hobbit', age: 30, hasMagic: false }
]
let sam = { name: 'Sam', height: 62, race: 'hobbit', age: 29, hasMagic: false }

brothers.unshift(sam)
console.log(brothers)

//* 1.Метод map()

// метод нужен для создания нового массива на основании исходного массива

// я хочу создать массив из имен наших героев 

// пример 1.

const names = brothers.map(brother => brother.name)

console.log(names)

// новый массив с именем и рассой

const raceName = brothers.map(brother => brother.race + ' ' + brother.name)
console.log(raceName)


// 4.массив только высоких братьев 
const tallBrozhers = []

brothers.map(brother => {
    if (brother.height >= 180) {
        tallBrozhers.push(brother)
    }
})
console.log(tallBrozhers)



const size = brothers.map(brother => brother.height >= 170 ? 'Tall' : 'Small')

console.log(size)



// * forEach
// мутирующий метод, мы можем изменять элементы исходного массива
// также как и map() принимает в себя стрелочную функцию
// возвращенное значение - undefined, будьте осторожны и не присвойте его новому массиву случайно...

brothers.forEach(brother => brother.age += 1)

console.log(brothers)

brothers.forEach(brother => brother.name = brother.name.toUpperCase())

console.log(brothers)


//* filter возвращает массив эллементов уд

console.log(brothers.filter(el => el.age > 100))
console.log(brothers.filter(el => el.age > 100 && el.hasMagic === true))


//* find() самый первый который уодовлетворяет требования 

console.log(brothers.find(fi => fi.name.length < 4))



// * reduce()
// не мутирующий, возвращает новый массив
// принимает стрелочную функцию и начальное значение переменной

// допустим мы хотим получить сумму возрастов всех героев

let sum = 0

for (let i = 0; i < ages.length; i++) {
  sum += ages[i]
}

console.log(sum)

const sum2 = ages.reduce((acc, current) => acc + current, 3000)

console.log(sum2)

// вы можете вызывать методы по цепочке
// применять их друг за дружкой

const namesStr = brothers
  // здесь мы создаем массив имен братьев
  .map(el => el.name)
  // а здесь с новым массивом проводим конкатенацию элементов строк
  .reduce((acc, name) => acc + name + ', ', 'Brotherhood:  ')

console.log(namesStr)
